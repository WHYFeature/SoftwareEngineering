1. 单例模式（Singleton Pattern）

适用场景 ：日志管理器、配置中心、数据库连接池等系统中只需要一个实例的类。

核心思想：确保一个类只有一个实例，并提供全局访问点。

实现要点：

* 构造函数设为私有，外部无法创建对象
* 使用静态成员变量保存唯一实例
* 提供 getInstance() 方法返回该实例

注意事项：

* 本例为懒汉式写法，线程不安全
* 在多线程环境中应使用“同步锁”或“双重检查锁定”

```java
public class Logger {
    private static Logger instance;

    private Logger() {
        // 私有构造函数防止外部实例化
    }

    public static Logger getInstance() {
        if (instance == null) {
            instance = new Logger();  // 懒加载
        }
        return instance;
    }

    public void log(String message) {
        System.out.println("日志记录: " + message);
    }
}
```

2. 观察者模式（Observer Pattern）

适用场景 ：事件系统（按钮点击、通知）、发布订阅（新闻订阅、微博更新）等。

核心思想 ：一对多关系，当“被观察者”状态变化时通知所有“观察者”。

实现要点 ：

* 定义统一的 `Observer` 接口；
* `Teacher` 类中维护观察者列表，提供注册与通知方法；
* 通知发生时，调用每个观察者的 `update()` 方法。

```java
import java.util.ArrayList;
import java.util.List;

// 观察者接口
interface Observer {
    void update(String message);
}

// 具体观察者
class Student implements Observer {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    public void update(String message) {
        System.out.println(name + " 收到通知：" + message);
    }
}

// 被观察者
class Teacher {
    private List<Observer> students = new ArrayList<>();

    public void addObserver(Observer o) {
        students.add(o);
    }

    public void notifyObservers(String message) {
        for (Observer o : students) {
            o.update(message);
        }
    }

    public void publishHomework(String task) {
        System.out.println("老师布置作业：" + task);
        notifyObservers(task);
    }
}
```

3. 建造者模式（Builder Pattern）

适用场景：构建步骤固定但参数组合变化大的复杂对象（如网页、报告、套餐等）。

核心思想 ：将复杂对象的构建过程与表示解耦，使构建过程可以分步骤灵活调用。

优点 ：

* 实现链式调用，语义清晰；
* 易于维护和扩展，构建复杂对象时尤为方便。

```java
// 产品类
class Report {
    private String title;
    private String content;
    private String footer;

    public void setTitle(String title) { this.title = title; }
    public void setContent(String content) { this.content = content; }
    public void setFooter(String footer) { this.footer = footer; }

    public void display() {
        System.out.println("标题: " + title);
        System.out.println("内容: " + content);
        System.out.println("结尾: " + footer);
    }
}

// 建造者类
class ReportBuilder {
    private Report report = new Report();

    public ReportBuilder buildTitle(String title) {
        report.setTitle(title);
        return this;
    }

    public ReportBuilder buildContent(String content) {
        report.setContent(content);
        return this;
    }

    public ReportBuilder buildFooter(String footer) {
        report.setFooter(footer);
        return this;
    }

    public Report getReport() {
        return report;
    }
}
```

4. 中介者模式（Mediator Pattern）

适用场景 ：多个对象相互交互、互相依赖复杂的情况，如表单联动、聊天室、UI 控件交互。

核心思想 ：通过中介者对象统一管理多个组件的交互，避免组件之间的直接引用。

组件行为解耦 ：

* Button和TextBox不直接通信，而是通过DialogMediator；
* 中介者根据发送者与事件来决定如何协调其他组件行为；

```java
// 中介者接口
interface Mediator {
    void notify(Component sender, String event);
}

// 抽象组件
abstract class Component {
    protected Mediator mediator;

    public Component(Mediator mediator) {
        this.mediator = mediator;
    }
}

// 具体组件A
class Button extends Component {
    public Button(Mediator mediator) {
        super(mediator);
    }

    public void click() {
        System.out.println("按钮被点击");
        mediator.notify(this, "click");
    }
}

// 具体组件B
class TextBox extends Component {
    public TextBox(Mediator mediator) {
        super(mediator);
    }

    public void clear() {
        System.out.println("文本框被清空");
    }
}

// 具体中介者
class DialogMediator implements Mediator {
    private Button button;
    private TextBox textBox;

    public void setButton(Button b) { this.button = b; }
    public void setTextBox(TextBox t) { this.textBox = t; }

    public void notify(Component sender, String event) {
        if (sender == button && event.equals("click")) {
            textBox.clear();
        }
    }
}
```

---

总结表格

| 模式名称   | 应用示例               | 优点                       | 缺点 / 注意事项            |
| ---------- | ---------------------- | -------------------------- | -------------------------- |
| 单例模式   | 日志记录器、配置读取器 | 保证唯一实例，全局访问     | 多线程下需同步控制         |
| 观察者模式 | 通知系统、GUI事件响应  | 解耦发布与订阅者，响应灵活 | 过多观察者可能导致性能问题 |
| 建造者模式 | 报告生成器、网页组件   | 分步构建，结构清晰         | 对于简单对象构建略显复杂   |
| 中介者模式 | 界面组件通信、模块解耦 | 降低耦合，统一通信管理     | 中介者可能过于庞大和复杂   |
