# 2025-5-16会议纪要

## 会议纪要

1.对比书上各种软件体系结构风格和视图特点，思考自己项目属于哪种设计风格

2.参阅课本和网上资料，研究经典软件体系结构案例KWIC

3.继续完成SAD

## 主要内容

### 1.项目风格

#### 1.1本项目风格

研究发现，项目属于客户-服务器风格，系统所使用的所有数据信息均由统一的数据库存放，客户使用浏览器等前端工具访问指定url获取网页，在网页上进行相关操作，每个网页相互之间通过session沟通，独立性较高，所有的网页活动会将请求发送给处理业务逻辑的应用服务器上进行相关活动，应用服务器访问数据库服务器获取数据。

#### 1.2扩展

MVC旨在将应用程序的逻辑分为三个核心组件： **模型** 、**视图** 和  **控制器** ，以实现关注点分离，提高代码的可维护性和扩展性。

三个核心组件的作用如下：

1. **模型**
   * **职责** ：管理数据和业务逻辑，负责数据的存储、检索、验证和处理。
   * **特点** ：独立于用户界面，不关心数据如何展示或被操作。
   * **示例** ：数据库操作、计算逻辑、状态管理等。
2. **视图**
   * **职责** ：展示数据，提供用户界面（UI）。
   * **特点** ：被动更新，不处理业务逻辑，仅反映模型的当前状态。
   * **示例** ：网页的HTML模板、桌面应用的UI组件。
3. **控制器**
   * **职责** ：接收用户输入，协调模型和视图的交互。
   * **特点** ：处理用户请求，调用模型处理数据，选择视图进行响应。
   * **示例** ：处理HTTP请求的路由、表单验证逻辑。

执行逻辑为：用户通过**视图**触发操作->**视图**将操作传递给 **控制器** ->**控制器**解析输入，调用**模型**处理业务逻辑->**模型**完成处理后，通知**视图**更新->**视图**从**模型**获取最新数据并重新渲染界面。

### 2.体系结构风格评分

#### 2.1针对KWIC的比较表

| **属性**         | 权重 | 共享数据 | 数据抽象 | 隐含调用 | 管道和过滤器 |
| :--------------- | :--- | :------- | -------- | -------- | ------------ |
| 易于改变算法     | 1    | 1        | 2        | 4        | 5            |
| 易于改变数据表示 | 4    | 1        | 5        | 4        | 1            |
| 易于改变功能     | 3    | 4        | 1        | 3        | 5            |
| 好的性能         | 3    | 4        | 3        | 3        | 5            |
| 有效的数据表示   | 3    | 5        | 5        | 5        | 4            |
| 易于复用         | 5    | 1        | 4        | 5        | 1            |
| 总计             |      | 49       | 69       | 78       | 62           |

1. **KWIC系统**：选择**管道和过滤器风格**，原因如下：
   - 算法和功能易变性是KWIC的核心需求（如频繁调整排序规则或新增预处理步骤），管道风格在此类属性上满分。
   - 尽管复用性和数据表示改动得分低，但KWIC通常作为独立工具使用，复用需求次要。
2. **长期演进的项目**：若预期KWIC需持续扩展（如支持多种数据源、分布式处理），可选择**数据抽象风格**（面向对象），平衡灵活性与维护性。
3. **避免共享数据和隐含调用**：前者太僵化，后者过度复杂化KWIC的简单数据处理需求。

#### 2.2各风格评分

##### **2.2.1主程序-子程序风格**

| **属性**         | **评分**  | **说明**                                   |
| :--------------- | :-------- | :----------------------------------------- |
| 易于改变算法     | 2         | 需修改子程序内部逻辑，可能影响调用方。     |
| 易于改变数据表示 | 1         | 数据表示硬编码在子程序中，改动成本高。     |
| 易于改变功能     | 2         | 需重构主程序流程，可能引入连锁修改。       |
| 好的性能         | 5         | 直接调用，无额外开销。                     |
| 有效的数据表示   | 3         | 通常使用简单数据结构（如数组），效率中等。 |
| 易于复用         | 1         | 子程序高度依赖上下文。                     |
| **权重后总分**   | **41/95** | 适合简单、稳定的场景。                     |

##### **2.2.2 面向对象风格**

| **属性**         | **评分**  | **说明**                                             |
| :--------------- | :-------- | :--------------------------------------------------- |
| 易于改变算法     | 4         | 通过多态或策略模式灵活替换算法（如 `ISorter`接口）。 |
| 易于改变数据表示 | 3         | 数据封装在类中，但修改需调整相关方法。               |
| 易于改变功能     | 4         | 新增类（如 `DuplicateRemover`）不影响现有代码。      |
| 好的性能         | 4         | 略低于主程序风格，但差异可忽略。                     |
| 有效的数据表示   | 4         | 可灵活选择数据结构（如哈希表加速查询）。             |
| 易于复用         | 4         | 类或接口可独立复用。                                 |
| **总分**         | **72/95** | 平衡性好，适合中等复杂度系统。                       |

##### **2.2.3管道-过滤器风格**

| **属性**         | **评分**  | **说明**                                            |
| :--------------- | :-------- | :-------------------------------------------------- |
| 易于改变算法     | 5         | 替换过滤器（如 `SortFilter`）即可，不影响其他组件。 |
| 易于改变数据表示 | 5         | 过滤器间通过标准数据流交互，内部表示可自由调整。    |
| 易于改变功能     | 5         | 新增过滤器（如 `FilterByLength`）只需插入管道。     |
| 好的性能         | 2         | 数据流序列化可能成为瓶颈。                          |
| 有效的数据表示   | 4         | 流式处理适合逐行数据，但需权衡内存效率。            |
| 易于复用         | 5         | 过滤器可独立用于其他流水线。                        |
| **总分**         | **83/95** | **最佳灵活性**，适合数据处理场景。                  |

##### **2.2.4事件驱动风格**

| **属性**         | **评分**  | **说明**                                     |
| :--------------- | :-------- | :------------------------------------------- |
| 易于改变算法     | 3         | 需修改事件处理器逻辑，可能影响事件链。       |
| 易于改变数据表示 | 2         | 事件数据格式需全局一致，改动成本高。         |
| 易于改变功能     | 3         | 新增事件类型需协调发布/订阅方。              |
| 好的性能         | 3         | 异步处理引入延迟，但可并行化。               |
| 有效的数据表示   | 3         | 事件数据通常为通用格式（如JSON），效率较低。 |
| 易于复用         | 3         | 事件处理器依赖特定事件协议。                 |
| **总分**         | **53/95** | 适合异步系统，但KWIC不推荐。                 |

##### **2.2.5微内核风格**

| **属性**         | **评分**  | **说明**                               |
| :--------------- | :-------- | :------------------------------------- |
| 易于改变算法     | 5         | 算法实现为插件，可动态替换。           |
| 易于改变数据表示 | 4         | 内核定义数据接口，插件内部可自由实现。 |
| 易于改变功能     | 5         | 新增插件无需修改内核。                 |
| 好的性能         | 3         | 插件通信需跨进程/模块，开销较大。      |
| 有效的数据表示   | 4         | 插件可优化自身数据表示。               |
| 易于复用         | 4         | 插件需符合内核规范，复用性受限。       |
| **总分**         | **77/95** | 适合长期演化的复杂系统。               |

（评价的权重参考课本表5-3）

#### **2.3综合对比与推荐**

| **风格**        | **总分** | **优势属性**                 | **劣势属性**         |
| :-------------- | :------- | :--------------------------- | :------------------- |
| 主程序-子程序   | 41       | 性能                         | 可修改性、复用性差   |
| 面向对象        | 72       | 平衡性                       | 数据表示改动成本中等 |
| **管道-过滤器** | 83       | **算法/功能/数据表示易改动** | 性能略低             |
| 事件驱动        | 53       | 异步处理                     | 数据表示僵硬         |
| 微内核          | 77       | 高扩展性                     | 性能开销             |

