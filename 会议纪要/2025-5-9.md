# 2025-5-9会议纪要

## 内容概要

1. 深入理解UML
2. 了解计算机学科中的逻辑
3. 学习对比软件体系结构设计GB和IEEE最新SAD (Software Architecture Document)的标准
4. 研究经典软件体系结构案例
5. 完成自己项目的SRS

## 主要内容

### 1.深入理解UML

#### 1.1.UML基础

    UML是一种通用的建模语言，用于对软件密集型系统进行可视化、说明、构造和文档化。它不是一种编程语言，而是一种标准的建模语言，提供了多个图示来帮助系统分析和设计。

UML支持以下几种建模视图：

1. **结构视图** ：如类图、对象图、组件图、部署图，用于展示系统静态结构。
2. **行为视图** ：如用例图、活动图、状态图，用于展示系统的动态行为。
3. **交互视图** ：如序列图、通信图，专注于对象之间的交互。

#### 1.2.UML建模一般步骤

1.2.1.需求建模：使用例图识别与系统交互的外部实体，即参与者；识别系统需要提供的功能，即用例，并确定两者之间的关系，明确系统边界和核心业务功能。

1.2.2.静态建模：使用类图和对象图设计系统的类、接口、模块和它们之间的关系，反应系统的数据结构和模块组织。

1.2.3.动态建模：使用状态图和活动图，描述系统随时间变化的行为和响应机制，描述事件触发、状态转移和条件判断等内容。

1.2.4.交互建模：通过序列图和通信图，展示对象之间的消息传递、调用顺序，确定系统功能实现所需的对象写作，进而完成程序逻辑实现。

1.2.5.实现建模：通过组件图和部署图，确定组件与接口纸质件的通信关系，明确物理实现与部署架构。

#### 1.3.建模过程注意事项

* **迭代建模** ：建模是持续迭代的过程，尤其适用于敏捷开发。
* **从粗到细** ：先建粗略模型再逐步细化。
* **注重一致性** ：不同图之间必须语义一致。
* **配合工具使用** ：如 Enterprise Architect、StarUML、Visual Paradigm 等。

### 2.了解计算机学科中的逻辑

#### 2.1 命题逻辑（Propositional Logic）

* 定义：

  命题逻辑处理真假值明确的语句，通过逻辑连接词（如 ∧、∨、¬、→）组合形成复合命题。
* 语法：

  原子命题：`p, q, r, ...`
  连接词：

  ¬p：非
  p ∧ q：与
  p ∨ q：或
  p → q：蕴含（如果p那么q）
  p ↔ q：等价
* 语义：

  每个命题变量被赋予 `true` 或 `false`，整个表达式通过真值表进行求值
* 应用典型：

  电路设计：布尔代数优化、布尔函数等价性判定
  条件判断优化：编译器中用于控制流优化、死代码删除
  SAT 问题：判断某个命题逻辑表达式是否有满足赋值（NP完全问题）

#### 2.2 谓词逻辑（First-Order Logic, FOL）

* 定义：

  在命题逻辑基础上引入了变量、函数、谓词（关系）和量词，可以表达更复杂的结构性信息。
* 语法：

  原子公式：`P(x)`，`Loves(Alice, Bob)`
  量词：

  ∀x P(x)：对所有x都成立
  ∃x P(x)：存在一个x使得成立
* 语义：

  有一个“领域”D作为变量的取值范围
  使用谓词表示 D 上的关系，函数表示 D → D 的映射
  根据解释结构 I 和赋值函数进行真值计算
* 应用典型：

  数据库：SQL 查询优化可形式化为谓词逻辑表达
  AI：知识表示（如"所有人都怕鬼"：∀x Human(x) → Fear(x, Ghost)）
  静态代码分析：用于表达断言、前后置条件，自动推理程序属性

#### 2.3 时序逻辑（Temporal Logic）

* 定义：

  扩展逻辑以包含时间概念，适合描述系统状态随时间演化的性质。主要有LTL——线性时序逻辑和CTL——计算树逻辑两种。
* 常见运算符（以 LTL 为例）：

  ◇p（eventually p）：某个时刻 p 成立
  □p（always p）：始终成立
  p U q（p until q）：p 一直成立直到 q 成立
  Xp（next p）：下一状态满足 p
* 语义：

  系统行为建模为状态序列
  对状态路径中的每个点按公式解释其成立性
* 应用典型：

  并发系统验证：如“永不死锁”、“每个请求最终被响应”
  通信协议建模：如“发送之后必须等待 ACK 才能继续”
  实时系统：结合时间自动机工具（如 UPPAAL）做精确时序分析

#### 2.4 模态逻辑（Modal Logic）

* 定义：

  引入“可能性”、“必要性”等 modal 运算符。典型形式：

  ◻p（necessarily p）
  ◇p（possibly p）
  在多智能体逻辑中常用：Ki p（代理 i 知道 p）
* 语义（Kripke语义）：

  世界（状态）集合W
  可达关系R（某状态是否“可以看到”另一个）
  在模型中 p 是否成立取决于它在所有可达世界中的真值
* 应用典型：

  多智能体建模：如“代理 A 知道 B 不知道 X”
  安全协议验证：如 BAN Logic
  操作系统与网络安全：权限、访问控制逻辑

#### 2.5 Hoare逻辑（Hoare Logic）

* 定义：

  用于形式化验证程序正确性。表达式形式为：

```text
{P} C {Q}
```

    P：前置条件
 	C：程序片段
 	Q：后置条件
  意思是：如果开始时满足 P，执行 C 后将满足 Q。

* 推理规则：

  赋值规则、组合语句规则、循环不变式
  支持部分正确性（只保证结果）和完全正确性（加上终止性）
* 应用典型：

  自动程序验证：如验证排序算法是否真的对数组排序
  合约式编程：语言如 Eiffel 中原生支持
  工具：Dafny、SPARK Ada、Frama-C 可自动推理/生成证明义务

#### 2.6 μ演算（Mu-Calculus）

* 定义：

  是一种强大的固定点逻辑，可以表达 LTL、CTL 甚至更复杂的嵌套时序属性。
* 基本形式：

  μX.φ(X)：最小固定点
  νX.φ(X)：最大固定点
  支持递归定义，比如表达“能反复回到安全状态”。
* 语义：

  通过递归地展开和构造满足条件的状态集合来进行解释。
* 应用典型：

  模型检测器内部实现（如 SPIN、NuSMV）可将 LTL 转化为 μ演算处理
  工业控制系统：复杂安全属性建模与验证
  工具支持：mCRL2、CADP（工业级验证平台）

### 3.关于SAD

#### 4.研究经典软件体系结构案例：

##### 学习、检索研究经典软件体系结构案例：Keyword in Context (KWIC)

###### 一、KWIC 系统简介

**KWIC**（Keyword in Context）是一种文本索引系统，其基本功能是对一系列文本行（如文档标题）生成循环移位（circular shift），并按字典序排序，以便根据关键字进行索引。KWIC常用于文献索引、搜索引擎等。

**输入示例：**

```
Descent of Man
The Ascent of Man
The Old Man and the Sea
A Portrait of the Artist as a Young Man
```

**输出（KWIC索引）示例：**

```
A Portrait of the Artist as a Young Man
Artist as a Young Man A Portrait of the
Ascent of Man The
Descent of Man
...
```

###### 二、KWIC 的体系结构设计方案

在Parnas的论文中，KWIC被用于对比两种模块划分方法：**按照处理步骤划分** 和 **按照信息隐藏划分**。

    1. 按照处理步骤划分（传统方法）

将系统划分为如下模块：

- 输入模块
- 循环移位模块
- 排序模块
- 输出模块

这种方法反映的是程序的执行流程，但**模块间耦合高**，对变化的适应性差。

    2.按照信息隐藏划分（Parnas推荐方法）

Parnas提出应根据“**隐藏可能发生变化的信息**”来划分模块，例如：

- 文本行的存储格式（是否使用数组、链表）
- 排序算法（冒泡、快速）
- 大小写敏感性
- 单词边界的定义

因此，模块可以如下划分：

- **LineStorage模块**：管理文本行的存储和访问。
- **CircularShifter模块**：生成所有循环移位。
- **Alphabetizer模块**：排序循环移位。
- **Output模块**：输出结果。

这种设计思想强调：**每个模块都应隐藏一个设计决策或变化点，从而提高系统的可维护性与扩展性**。

###### 三、KWIC 案例的意义

KWIC案例是软件架构教育中的经典范例，主要意义包括：

- **引入模块化设计理念**
- 强调**信息隐藏**和**抽象**
- 启发**软件可维护性与演化性**思考
- 是**面向对象设计**和**软件构件重用**的基础案例

###### 四、现代视角的扩展

在现代软件体系结构中，也可以将KWIC扩展为：

- 使用**MVC架构**进行组织
- 引入**事件驱动或观察者模式**
- 使用**面向对象语言（如Java或Python）**重构系统

##### 学习、检索研究经典软件体系结构案例：Sea Buoy

###### 一、Sea Buoy 案例简介

**Sea Buoy 系统**是一个**环境监测浮标系统**，部署在海洋中，用于收集环境数据，如温度、盐度、水压、风速等，并定期将数据上传到岸上的服务器或研究中心。

系统具备以下典型功能：

- 传感器数据采集
- 数据处理与初步分析（滤波、异常检测）
- 存储与缓冲
- 与岸基通信系统通信（如卫星通信）
- 能源管理（使用太阳能或电池供电）

###### 二、Sea Buoy 的典型体系结构设计

* 架构风格：**面向服务的分层架构 + 事件驱动**

系统通常由以下几个核心模块构成：

**1.Sensor Interface Layer（传感器接口层）**

- 驱动各类传感器（温度、盐度、压力等）
- 提供统一的接口抽象以简化高层访问

**2.Data Acquisition & Processing Layer（数据采集与处理层）**
- 定时采集传感器数据
- 执行本地数据处理（如校准、过滤、压缩）
- 实现数据缓存机制

**3.Communication Layer（通信层）**
- 管理与岸基站点的通信（如通过 GSM、卫星、无线电）
- 处理通信失败的重试、数据打包和加密

**4.Storage Layer（本地存储）**
- 存储临时或历史数据
- 在通信不可用时提供缓存和持久化

**5.Power Management Layer（电源管理）**
- 控制设备的功耗模式（如深度睡眠）
- 与太阳能电池和蓄电池协同工作
- 决策何时进入低功耗模式

**6.Control & Monitoring Layer（控制与监控层）**
- 对系统整体状态进行监控（硬件健康状况、内存使用等）
- 提供系统配置的远程控制能力

###### 三、关键设计关注点

Sea Buoy 是一个典型的资源受限系统，设计时需考虑以下几个问题：

- **功耗优化**：利用低功耗传感器、低频采样、定时唤醒机制
- **通信不稳定性**：实现数据持久化、本地缓冲和通信重试机制
- **系统鲁棒性**：应对设备故障、传感器失灵、海洋极端环境
- **可远程更新与监控**：采用 OTA（Over The Air）方式更新固件
- **安全性**：数据加密、身份认证、防止物理篡改

###### 四、常见技术与工具

- **RTOS（实时操作系统）**：如 FreeRTOS、Zephyr
- **嵌入式平台**：如 STM32、ARM Cortex-M
- **通信协议**：MQTT、LoRaWAN、Iridium、NB-IoT
- **数据格式**：JSON、CBOR、Protocol Buffers
- **远程监控工具**：AWS IoT、Azure IoT Hub、Custom Dashboard

## 五、该案例在教学中的价值

Sea Buoy 被广泛用于教学与研究中，涵盖以下软件体系结构主题：

- 嵌入式系统设计
- 分层架构与模块化
- 实时系统调度与中断处理
- 异常处理与冗余机制
- 安全通信与能耗优化
